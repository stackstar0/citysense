"""
City Brain - The Central Intelligence of RegeneraX
Coordinates all urban sensing, analysis, and adaptive responses
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
import json

from .sensor_manager import SensorManager
from .data_processor import DataProcessor
from ai_engine.prediction_engine import PredictionEngine
from ai_engine.pattern_recognition import PatternRecognition
from ecosystem.impact_analyzer import ImpactAnalyzer
from regenerative.optimization_engine import OptimizationEngine

logger = logging.getLogger(__name__)

@dataclass
class CityVitalSigns:
    """Current vital signs of the city ecosystem"""
    timestamp: datetime
    air_quality_index: float
    energy_efficiency: float
    traffic_flow_rate: float
    economic_activity: float
    ecological_health: float
    social_wellbeing: float
    resilience_score: float
    stress_indicators: Dict[str, float]

    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result['timestamp'] = self.timestamp.isoformat()
        return result

@dataclass
class CityInsight:
    """Actionable insights generated by the city brain"""
    insight_id: str
    category: str  # "climate", "economy", "ecology", "infrastructure"
    priority: str  # "critical", "high", "medium", "low"
    title: str
    description: str
    predicted_impact: Dict[str, float]
    recommended_actions: List[str]
    affected_areas: List[str]
    confidence_score: float
    timestamp: datetime

class CityBrain:
    """
    The central intelligence system that orchestrates urban sensing,
    analysis, and regenerative responses
    """

    def __init__(self, data_processor: DataProcessor, sensor_manager: SensorManager):
        self.data_processor = data_processor
        self.sensor_manager = sensor_manager
        self.prediction_engine = PredictionEngine()
        self.pattern_recognition = PatternRecognition()
        self.impact_analyzer = ImpactAnalyzer()
        self.optimization_engine = OptimizationEngine()

        self.vital_signs: Optional[CityVitalSigns] = None
        self.insights: List[CityInsight] = []
        self.status = "initializing"

        # Analysis intervals
        self.vital_signs_interval = 30  # seconds
        self.insight_generation_interval = 300  # 5 minutes
        self.optimization_interval = 1800  # 30 minutes

        self._running = False
        self._tasks: List[asyncio.Task] = []

    async def start(self):
        """Start the city brain intelligence processes"""
        logger.info("ðŸ§  Starting City Brain intelligence systems")
        self._running = True
        self.status = "starting"

        # Start background analysis tasks
        self._tasks = [
            asyncio.create_task(self._vital_signs_monitor()),
            asyncio.create_task(self._insight_generator()),
            asyncio.create_task(self._optimization_runner()),
            asyncio.create_task(self._pattern_analyzer())
        ]

        self.status = "active"
        logger.info("âœ… City Brain is now actively monitoring urban ecosystem")

    async def stop(self):
        """Stop all city brain processes"""
        logger.info("â¹ Stopping City Brain systems")
        self._running = False
        self.status = "stopping"

        # Cancel all tasks
        for task in self._tasks:
            task.cancel()

        await asyncio.gather(*self._tasks, return_exceptions=True)
        self.status = "offline"
        logger.info("âœ… City Brain shutdown complete")

    async def _vital_signs_monitor(self):
        """Continuously monitor and update city vital signs"""
        while self._running:
            try:
                # Collect latest sensor data
                sensor_data = await self.sensor_manager.get_latest_readings()

                if sensor_data:
                    # Calculate vital signs
                    vital_signs = await self._calculate_vital_signs(sensor_data)
                    self.vital_signs = vital_signs

                    # Store in data processor
                    await self.data_processor.store_vital_signs(vital_signs)

                    logger.debug(f"Updated city vital signs: Resilience {vital_signs.resilience_score:.2f}")

            except Exception as e:
                logger.error(f"Error in vital signs monitoring: {e}")

            await asyncio.sleep(self.vital_signs_interval)

    async def _insight_generator(self):
        """Generate actionable insights from city data"""
        while self._running:
            try:
                if self.vital_signs:
                    # Generate insights using AI engines
                    new_insights = await self._generate_insights()

                    # Filter and prioritize insights
                    filtered_insights = self._filter_insights(new_insights)

                    # Update insights list
                    self.insights.extend(filtered_insights)

                    # Keep only recent insights
                    cutoff_time = datetime.now() - timedelta(hours=24)
                    self.insights = [i for i in self.insights if i.timestamp > cutoff_time]

                    if filtered_insights:
                        logger.info(f"Generated {len(filtered_insights)} new city insights")

            except Exception as e:
                logger.error(f"Error in insight generation: {e}")

            await asyncio.sleep(self.insight_generation_interval)

    async def _optimization_runner(self):
        """Run city optimization algorithms"""
        while self._running:
            try:
                if self.vital_signs and self.insights:
                    # Run optimization algorithms
                    optimizations = await self.optimization_engine.optimize_city_systems(
                        self.vital_signs, self.insights
                    )

                    # Apply optimizations
                    for optimization in optimizations:
                        await self._apply_optimization(optimization)

                    if optimizations:
                        logger.info(f"Applied {len(optimizations)} city optimizations")

            except Exception as e:
                logger.error(f"Error in optimization: {e}")

            await asyncio.sleep(self.optimization_interval)

    async def _pattern_analyzer(self):
        """Analyze patterns in city behavior"""
        while self._running:
            try:
                # Get historical data
                historical_data = await self.data_processor.get_historical_data(
                    hours=24
                )

                if historical_data:
                    # Analyze patterns
                    patterns = await self.pattern_recognition.analyze_patterns(
                        historical_data
                    )

                    # Store patterns for future use
                    await self.data_processor.store_patterns(patterns)

                    logger.debug(f"Analyzed {len(patterns)} city behavior patterns")

            except Exception as e:
                logger.error(f"Error in pattern analysis: {e}")

            await asyncio.sleep(600)  # Run every 10 minutes

    async def _calculate_vital_signs(self, sensor_data: Dict[str, Any]) -> CityVitalSigns:
        """Calculate city vital signs from sensor data"""

        # Air Quality Index (0-100, higher is better)
        air_quality = self._calculate_air_quality(sensor_data.get('air_sensors', {}))

        # Energy Efficiency (0-100, higher is better)
        energy_efficiency = self._calculate_energy_efficiency(sensor_data.get('energy_sensors', {}))

        # Traffic Flow Rate (0-100, higher is better)
        traffic_flow = self._calculate_traffic_flow(sensor_data.get('traffic_sensors', {}))

        # Economic Activity (0-100, normalized)
        economic_activity = self._calculate_economic_activity(sensor_data.get('economic_data', {}))

        # Ecological Health (0-100, higher is better)
        ecological_health = self._calculate_ecological_health(sensor_data.get('environmental_sensors', {}))

        # Social Wellbeing (0-100, higher is better)
        social_wellbeing = self._calculate_social_wellbeing(sensor_data.get('social_indicators', {}))

        # Overall Resilience Score
        resilience_score = (
            air_quality * 0.2 +
            energy_efficiency * 0.15 +
            traffic_flow * 0.1 +
            economic_activity * 0.15 +
            ecological_health * 0.25 +
            social_wellbeing * 0.15
        )

        # Stress indicators
        stress_indicators = {
            "pollution_stress": max(0, 100 - air_quality),
            "energy_stress": max(0, 100 - energy_efficiency),
            "congestion_stress": max(0, 100 - traffic_flow),
            "ecological_stress": max(0, 100 - ecological_health),
            "social_stress": max(0, 100 - social_wellbeing)
        }

        return CityVitalSigns(
            timestamp=datetime.now(),
            air_quality_index=air_quality,
            energy_efficiency=energy_efficiency,
            traffic_flow_rate=traffic_flow,
            economic_activity=economic_activity,
            ecological_health=ecological_health,
            social_wellbeing=social_wellbeing,
            resilience_score=resilience_score,
            stress_indicators=stress_indicators
        )

    def _calculate_air_quality(self, air_data: Dict[str, Any]) -> float:
        """Calculate air quality index from sensor data"""
        if not air_data:
            return 50.0  # Default neutral value

        pm25 = air_data.get('pm25', 15)  # Âµg/mÂ³
        pm10 = air_data.get('pm10', 25)  # Âµg/mÂ³
        no2 = air_data.get('no2', 30)    # Âµg/mÂ³
        co = air_data.get('co', 2)       # mg/mÂ³

        # Convert to quality scores (inverse relationship with pollutants)
        pm25_score = max(0, 100 - (pm25 / 35 * 100))  # WHO guideline: 15 Âµg/mÂ³
        pm10_score = max(0, 100 - (pm10 / 45 * 100))  # WHO guideline: 45 Âµg/mÂ³
        no2_score = max(0, 100 - (no2 / 40 * 100))    # WHO guideline: 40 Âµg/mÂ³
        co_score = max(0, 100 - (co / 10 * 100))      # WHO guideline: 10 mg/mÂ³

        return (pm25_score + pm10_score + no2_score + co_score) / 4

    def _calculate_energy_efficiency(self, energy_data: Dict[str, Any]) -> float:
        """Calculate energy efficiency score"""
        if not energy_data:
            return 50.0

        renewable_ratio = energy_data.get('renewable_ratio', 0.3)  # 0-1
        consumption_per_capita = energy_data.get('consumption_per_capita', 5000)  # kWh/year
        grid_efficiency = energy_data.get('grid_efficiency', 0.85)  # 0-1

        # Higher renewable ratio is better
        renewable_score = renewable_ratio * 100

        # Lower consumption per capita is better (baseline: 3000 kWh/year)
        consumption_score = max(0, 100 - ((consumption_per_capita - 3000) / 50))

        # Higher grid efficiency is better
        efficiency_score = grid_efficiency * 100

        return (renewable_score + consumption_score + efficiency_score) / 3

    def _calculate_traffic_flow(self, traffic_data: Dict[str, Any]) -> float:
        """Calculate traffic flow efficiency"""
        if not traffic_data:
            return 50.0

        average_speed = traffic_data.get('average_speed_kmh', 30)  # km/h
        congestion_ratio = traffic_data.get('congestion_ratio', 0.3)  # 0-1
        public_transport_usage = traffic_data.get('public_transport_ratio', 0.4)  # 0-1

        # Higher average speed is better (optimal around 40 km/h for city)
        speed_score = min(100, (average_speed / 40) * 100)

        # Lower congestion is better
        congestion_score = (1 - congestion_ratio) * 100

        # Higher public transport usage is better
        transport_score = public_transport_usage * 100

        return (speed_score + congestion_score + transport_score) / 3

    def _calculate_economic_activity(self, economic_data: Dict[str, Any]) -> float:
        """Calculate economic activity score"""
        if not economic_data:
            return 50.0

        employment_rate = economic_data.get('employment_rate', 0.85)  # 0-1
        business_growth = economic_data.get('business_growth', 0.03)  # annual %
        innovation_index = economic_data.get('innovation_index', 0.6)  # 0-1

        employment_score = employment_rate * 100
        growth_score = min(100, max(0, (business_growth + 0.02) * 2500))  # -2% to 6% range
        innovation_score = innovation_index * 100

        return (employment_score + growth_score + innovation_score) / 3

    def _calculate_ecological_health(self, env_data: Dict[str, Any]) -> float:
        """Calculate ecological health score"""
        if not env_data:
            return 50.0

        green_space_ratio = env_data.get('green_space_ratio', 0.2)  # 0-1
        biodiversity_index = env_data.get('biodiversity_index', 0.6)  # 0-1
        water_quality = env_data.get('water_quality_score', 70)  # 0-100
        waste_recycling_rate = env_data.get('recycling_rate', 0.4)  # 0-1

        green_score = green_space_ratio * 100
        biodiversity_score = biodiversity_index * 100
        recycling_score = waste_recycling_rate * 100

        return (green_score + biodiversity_score + water_quality + recycling_score) / 4

    def _calculate_social_wellbeing(self, social_data: Dict[str, Any]) -> float:
        """Calculate social wellbeing score"""
        if not social_data:
            return 50.0

        safety_index = social_data.get('safety_index', 0.7)  # 0-1
        education_access = social_data.get('education_access', 0.85)  # 0-1
        healthcare_access = social_data.get('healthcare_access', 0.8)  # 0-1
        housing_affordability = social_data.get('housing_affordability', 0.6)  # 0-1

        safety_score = safety_index * 100
        education_score = education_access * 100
        healthcare_score = healthcare_access * 100
        housing_score = housing_affordability * 100

        return (safety_score + education_score + healthcare_score + housing_score) / 4

    async def _generate_insights(self) -> List[CityInsight]:
        """Generate actionable insights from current city state"""
        insights = []

        if not self.vital_signs:
            return insights

        # Critical thresholds
        if self.vital_signs.resilience_score < 40:
            insights.append(CityInsight(
                insight_id=f"critical_resilience_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                category="infrastructure",
                priority="critical",
                title="City Resilience Below Critical Threshold",
                description="Overall city resilience has dropped below 40%. Immediate intervention required.",
                predicted_impact={"resilience": -15, "economic": -10, "social": -8},
                recommended_actions=[
                    "Activate emergency response protocols",
                    "Deploy additional resources to stressed areas",
                    "Implement temporary optimization measures"
                ],
                affected_areas=["citywide"],
                confidence_score=0.95,
                timestamp=datetime.now()
            ))

        # Air quality issues
        if self.vital_signs.air_quality_index < 30:
            insights.append(CityInsight(
                insight_id=f"air_quality_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                category="climate",
                priority="high",
                title="Poor Air Quality Detected",
                description="Air quality has deteriorated significantly. Health impacts imminent.",
                predicted_impact={"health": -20, "ecological": -15},
                recommended_actions=[
                    "Issue air quality alerts",
                    "Reduce traffic in affected areas",
                    "Activate air purification systems"
                ],
                affected_areas=["downtown", "industrial_district"],
                confidence_score=0.88,
                timestamp=datetime.now()
            ))

        # Energy efficiency opportunities
        if self.vital_signs.energy_efficiency < 60:
            insights.append(CityInsight(
                insight_id=f"energy_efficiency_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                category="economy",
                priority="medium",
                title="Energy Efficiency Improvement Opportunity",
                description="City energy systems operating below optimal efficiency.",
                predicted_impact={"economic": 8, "climate": 12},
                recommended_actions=[
                    "Optimize building energy systems",
                    "Increase renewable energy integration",
                    "Implement smart grid optimizations"
                ],
                affected_areas=["residential_areas", "commercial_district"],
                confidence_score=0.75,
                timestamp=datetime.now()
            ))

        return insights

    def _filter_insights(self, insights: List[CityInsight]) -> List[CityInsight]:
        """Filter and deduplicate insights"""
        # Remove duplicates based on category and priority
        seen = set()
        filtered = []

        for insight in insights:
            key = (insight.category, insight.priority, insight.title)
            if key not in seen:
                seen.add(key)
                filtered.append(insight)

        return filtered

    async def _apply_optimization(self, optimization: Dict[str, Any]):
        """Apply an optimization to city systems"""
        try:
            optimization_type = optimization.get('type')

            if optimization_type == 'traffic_signal_adjustment':
                await self.sensor_manager.adjust_traffic_signals(optimization['parameters'])
            elif optimization_type == 'energy_load_balancing':
                await self.sensor_manager.adjust_energy_distribution(optimization['parameters'])
            elif optimization_type == 'air_quality_response':
                await self.sensor_manager.activate_air_purification(optimization['parameters'])

            logger.info(f"Applied optimization: {optimization_type}")

        except Exception as e:
            logger.error(f"Failed to apply optimization: {e}")

    async def get_current_status(self) -> Dict[str, Any]:
        """Get current city brain status and vital signs"""
        return {
            "status": self.status,
            "vital_signs": self.vital_signs.to_dict() if self.vital_signs else None,
            "insights_count": len(self.insights),
            "critical_insights": len([i for i in self.insights if i.priority == "critical"]),
            "last_update": datetime.now().isoformat()
        }

    async def get_insights(self, category: Optional[str] = None,
                          priority: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get filtered insights"""
        filtered_insights = self.insights

        if category:
            filtered_insights = [i for i in filtered_insights if i.category == category]
        if priority:
            filtered_insights = [i for i in filtered_insights if i.priority == priority]

        return [asdict(insight) for insight in filtered_insights]